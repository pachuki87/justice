/**
 * VulnerabilityScanner - Sistema de detecci√≥n de vulnerabilidades
 * 
 * Este m√≥dulo proporciona funcionalidades para:
 * - Escanear vulnerabilidades en dependencias
 * - Analizar CVEs conocidas
 * - Evaluar riesgos de seguridad
 * - Generar reportes de vulnerabilidades
 * - Monitorear actualizaciones de seguridad
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class VulnerabilityScanner {
    constructor(options = {}) {
        this.options = {
            projectPath: options.projectPath || process.cwd(),
            severityThreshold: options.severityThreshold || 'moderate', // 'low', 'moderate', 'high', 'critical'
            includeDevDependencies: options.includeDevDependencies !== false,
            cacheResults: options.cacheResults !== false,
            cacheTimeout: options.cacheTimeout || 3600000, // 1 hora en ms
            ...options
        };
        
        this.packageJsonPath = path.join(this.options.projectPath, 'package.json');
        this.packageLockPath = path.join(this.options.projectPath, 'package-lock.json');
        this.cache = new Map();
        this.scanHistory = [];
        
        // Bases de datos de vulnerabilidades
        this.vulnerabilitySources = [
            {
                name: 'npm audit',
                priority: 1,
                enabled: true
            },
            {
                name: 'osv database',
                priority: 2,
                enabled: true,
                url: 'https://api.osv.dev/v1/query'
            },
            {
                name: 'github advisory',
                priority: 3,
                enabled: true,
                url: 'https://api.github.com/advisories'
            }
        ];
    }

    /**
     * Inicializa el esc√°ner de vulnerabilidades
     */
    async initialize() {
        try {
            await this.loadDependencies();
            console.log('‚úÖ VulnerabilityScanner inicializado correctamente');
            return true;
        } catch (error) {
            console.error('‚ùå Error al inicializar VulnerabilityScanner:', error.message);
            throw error;
        }
    }

    /**
     * Carga las dependencias del proyecto
     */
    async loadDependencies() {
        try {
            const packageJson = await fs.readFile(this.packageJsonPath, 'utf8');
            this.packageJson = JSON.parse(packageJson);
            
            try {
                const packageLock = await fs.readFile(this.packageLockPath, 'utf8');
                this.packageLock = JSON.parse(packageLock);
            } catch {
                console.warn('‚ö†Ô∏è No se encontr√≥ package-lock.json');
                this.packageLock = null;
            }
        } catch (error) {
            throw new Error(`Error al cargar dependencias: ${error.message}`);
        }
    }

    /**
     * Ejecuta un escaneo completo de vulnerabilidades
     */
    async scanVulnerabilities(options = {}) {
        const scanOptions = {
            includeDev: options.includeDev !== undefined ? options.includeDev : this.options.includeDevDependencies,
            severity: options.severity || this.options.severityThreshold,
            forceRefresh: options.forceRefresh || false,
            ...options
        };

        try {
            console.log('üîç Iniciando escaneo de vulnerabilidades...');
            
            const scanResult = {
                timestamp: new Date().toISOString(),
                scanId: this.generateScanId(),
                options: scanOptions,
                vulnerabilities: [],
                summary: {
                    total: 0,
                    critical: 0,
                    high: 0,
                    moderate: 0,
                    low: 0,
                    info: 0
                },
                metadata: {
                    scanDuration: 0,
                    packagesScanned: 0,
                    sourcesUsed: []
                },
                recommendations: []
            };

            const startTime = Date.now();

            // Escanear usando diferentes fuentes
            const scanPromises = this.vulnerabilitySources
                .filter(source => source.enabled)
                .map(source => this.scanFromSource(source, scanOptions));

            const scanResults = await Promise.allSettled(scanPromises);
            
            // Consolidar resultados
            const allVulnerabilities = [];
            const sourcesUsed = [];

            scanResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    allVulnerabilities.push(...result.value.vulnerabilities);
                    sourcesUsed.push(this.vulnerabilitySources[index].name);
                } else {
                    console.warn(`‚ö†Ô∏è Error en fuente ${this.vulnerabilitySources[index].name}:`, result.reason);
                }
            });

            // Eliminar duplicados y consolidar
            scanResult.vulnerabilities = this.consolidateVulnerabilities(allVulnerabilities);
            scanResult.metadata.sourcesUsed = sourcesUsed;

            // Filtrar por severidad
            scanResult.vulnerabilities = this.filterBySeverity(
                scanResult.vulnerabilities, 
                scanOptions.severity
            );

            // Calcular resumen
            this.calculateSummary(scanResult);

            // Generar recomendaciones
            scanResult.recommendations = this.generateRecommendations(scanResult);

            scanResult.metadata.scanDuration = Date.now() - startTime;
            scanResult.metadata.packagesScanned = this.countPackagesScanned();

            // Guardar en historial
            this.scanHistory.push(scanResult);

            // Cachear resultados
            if (this.options.cacheResults) {
                this.cacheScanResults(scanResult);
            }

            console.log(`‚úÖ Escaneo completado: ${scanResult.summary.total} vulnerabilidades encontradas`);
            return scanResult;
        } catch (error) {
            throw new Error(`Error en escaneo de vulnerabilidades: ${error.message}`);
        }
    }

    /**
     * Genera un ID √∫nico para el escaneo
     */
    generateScanId() {
        return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Escanea vulnerabilidades desde una fuente espec√≠fica
     */
    async scanFromSource(source, options) {
        switch (source.name) {
            case 'npm audit':
                return await this.scanWithNpmAudit(options);
            case 'osv database':
                return await this.scanWithOSV(options);
            case 'github advisory':
                return await this.scanWithGitHubAdvisory(options);
            default:
                return { vulnerabilities: [], metadata: {} };
        }
    }

    /**
     * Escanea usando npm audit
     */
    async scanWithNpmAudit(options) {
        try {
            const auditOutput = execSync('npm audit --json', {
                cwd: this.options.projectPath,
                encoding: 'utf8'
            });

            const auditData = JSON.parse(auditOutput);
            const vulnerabilities = this.parseNpmAuditResults(auditData);

            return {
                source: 'npm audit',
                vulnerabilities,
                metadata: {
                    totalAdvisories: auditData.metadata?.vulnerabilities?.total || 0,
                    totalDependencies: Object.keys(auditData.dependencies || {}).length
                }
            };
        } catch (error) {
            // npm audit puede salir con c√≥digo 1 incluso con solo advertencias
            try {
                const auditOutput = error.stdout?.toString() || '{}';
                const auditData = JSON.parse(auditOutput);
                const vulnerabilities = this.parseNpmAuditResults(auditData);

                return {
                    source: 'npm audit',
                    vulnerabilities,
                    metadata: {
                        totalAdvisories: auditData.metadata?.vulnerabilities?.total || 0,
                        totalDependencies: Object.keys(auditData.dependencies || {}).length
                    }
                };
            } catch (parseError) {
                return {
                    source: 'npm audit',
                    vulnerabilities: [],
                    metadata: { error: parseError.message }
                };
            }
        }
    }

    /**
     * Parsea los resultados de npm audit
     */
    parseNpmAuditResults(auditData) {
        const vulnerabilities = [];

        if (auditData.vulnerabilities) {
            for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
                for (const advisory of vulnData) {
                    vulnerabilities.push({
                        id: advisory.id,
                        packageName,
                        title: advisory.title,
                        description: advisory.overview || advisory.description,
                        severity: this.normalizeSeverity(advisory.severity),
                        url: advisory.url,
                        cve: advisory.cwe ? `CVE-${advisory.cwe}` : null,
                        versions: {
                            vulnerable: advisory.vulnerable_versions,
                            patched: advisory.patched_versions
                        },
                        fixAvailable: advisory.fix_available,
                        recommendation: advisory.recommendation,
                        source: 'npm audit',
                        discoveredAt: new Date().toISOString(),
                        metadata: {
                            module_name: advisory.module_name,
                            severity_numeric: advisory.severity_numeric,
                            publish_date: advisory.publish_date,
                            update_date: advisory.update_date
                        }
                    });
                }
            }
        }

        return vulnerabilities;
    }

    /**
     * Escanea usando OSV (Open Source Vulnerability database)
     */
    async scanWithOSV(options) {
        const vulnerabilities = [];
        
        try {
            const packages = this.getAllPackages(options.includeDev);
            
            for (const pkg of packages) {
                const osvVulns = await this.queryOSVDatabase(pkg.name, pkg.version);
                vulnerabilities.push(...osvVulns);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Error escaneando con OSV:', error.message);
        }

        return {
            source: 'osv database',
            vulnerabilities,
            metadata: {
                packagesQueried: this.getAllPackages(options.includeDev).length
            }
        };
    }

    /**
     * Consulta la base de datos OSV
     */
    async queryOSVDatabase(packageName, version) {
        try {
            const query = {
                package: {
                    name: packageName,
                    ecosystem: 'npm'
                },
                version: version
            };

            const response = await fetch('https://api.osv.dev/v1/query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(query)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            const vulnerabilities = [];

            if (data.vulns) {
                for (const vuln of data.vulns) {
                    vulnerabilities.push({
                        id: vuln.id,
                        packageName,
                        title: vuln.summary || `Vulnerability in ${packageName}`,
                        description: vuln.details,
                        severity: this.extractOSVSeverity(vuln),
                        url: vuln.database_specific?.url || vuln.id,
                        cve: this.extractCVEFromOSV(vuln),
                        versions: {
                            vulnerable: this.extractVulnerableVersions(vuln),
                            patched: this.extractPatchedVersions(vuln)
                        },
                        fixAvailable: this.hasOSVFix(vuln, version),
                        recommendation: this.generateOSVRecommendation(vuln),
                        source: 'osv database',
                        discoveredAt: new Date().toISOString(),
                        metadata: {
                            published: vuln.published,
                            modified: vuln.modified,
                            withdrawn: vuln.withdrawn,
                            database_specific: vuln.database_specific,
                            severity_details: vuln.severity
                        }
                    });
                }
            }

            return vulnerabilities;
        } catch (error) {
            console.warn(`‚ö†Ô∏è Error consultando OSV para ${packageName}:`, error.message);
            return [];
        }
    }

    /**
     * Extrae la severidad de OSV
     */
    extractOSVSeverity(vuln) {
        if (vuln.severity && vuln.severity.length > 0) {
            const severity = vuln.severity[0];
            return severity.type === 'CVSS_V3' 
                ? this.cvssToSeverity(severity.score)
                : severity.score.toLowerCase();
        }
        return 'unknown';
    }

    /**
     * Convierte puntuaci√≥n CVSS a severidad
     */
    cvssToSeverity(score) {
        if (score >= 9.0) return 'critical';
        if (score >= 7.0) return 'high';
        if (score >= 4.0) return 'moderate';
        if (score > 0) return 'low';
        return 'info';
    }

    /**
     * Extrae CVE de datos OSV
     */
    extractCVEFromOSV(vuln) {
        if (vuln.aliases) {
            for (const alias of vuln.aliases) {
                if (alias.startsWith('CVE-')) {
                    return alias;
                }
            }
        }
        return null;
    }

    /**
     * Extrae versiones vulnerables de OSV
     */
    extractVulnerableVersions(vuln) {
        if (vuln.affected) {
            const versions = [];
            for (const affected of vuln.affected) {
                if (affected.versions) {
                    versions.push(...affected.versions);
                }
            }
            return versions.join(', ');
        }
        return 'Unknown';
    }

    /**
     * Extrae versiones parchadas de OSV
     */
    extractPatchedVersions(vuln) {
        if (vuln.affected) {
            const versions = [];
            for (const affected of vuln.affected) {
                if (affected.versions) {
                    versions.push(...affected.versions);
                }
            }
            return versions.join(', ');
        }
        return 'Unknown';
    }

    /**
     * Verifica si hay fix disponible en OSV
     */
    hasOSVFix(vuln, currentVersion) {
        // L√≥gica simplificada - en producci√≥n se analizar√≠a m√°s detalladamente
        return vuln.affected && vuln.affected.length > 0;
    }

    /**
     * Genera recomendaci√≥n para OSV
     */
    generateOSVRecommendation(vuln) {
        return `Update to a fixed version. See ${vuln.database_specific?.url || vuln.id} for details.`;
    }

    /**
     * Escanea usando GitHub Advisory
     */
    async scanWithGitHubAdvisory(options) {
        const vulnerabilities = [];
        
        try {
            const packages = this.getAllPackages(options.includeDev);
            
            for (const pkg of packages) {
                const ghVulns = await this.queryGitHubAdvisory(pkg.name);
                vulnerabilities.push(...ghVulns);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Error escaneando con GitHub Advisory:', error.message);
        }

        return {
            source: 'github advisory',
            vulnerabilities,
            metadata: {
                packagesQueried: this.getAllPackages(options.includeDev).length
            }
        };
    }

    /**
     * Consulta GitHub Advisory
     */
    async queryGitHubAdvisory(packageName) {
        try {
            const query = `
                query {
                    securityVulnerabilities(first: 100, ecosystem: NPM, package: "${packageName}") {
                        nodes {
                            advisory {
                                ghsaId
                                summary
                                description
                                severity
                                publishedAt
                                updatedAt
                                withdrawnAt
                                cvss {
                                    score
                                    vectorString
                                }
                                references {
                                    url
                                }
                                identifiers {
                                    type
                                    value
                                }
                            }
                            firstPatchedVersion {
                                identifier
                            }
                            vulnerableVersionRange
                        }
                    }
                }
            `;

            const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.GITHUB_TOKEN || ''}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ query })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            const vulnerabilities = [];

            if (data.data?.securityVulnerabilities?.nodes) {
                for (const vuln of data.data.securityVulnerabilities.nodes) {
                    vulnerabilities.push({
                        id: vuln.advisory.ghsaId,
                        packageName,
                        title: vuln.advisory.summary,
                        description: vuln.advisory.description,
                        severity: this.normalizeSeverity(vuln.advisory.severity),
                        url: `https://github.com/advisories/${vuln.advisory.ghsaId}`,
                        cve: this.extractCVEFromGitHub(vuln.advisory.identifiers),
                        versions: {
                            vulnerable: vuln.vulnerableVersionRange,
                            patched: vuln.firstPatchedVersion?.identifier || 'Not available'
                        },
                        fixAvailable: !!vuln.firstPatchedVersion,
                        recommendation: `Update to version ${vuln.firstPatchedVersion?.identifier || 'latest'}`,
                        source: 'github advisory',
                        discoveredAt: new Date().toISOString(),
                        metadata: {
                            publishedAt: vuln.advisory.publishedAt,
                            updatedAt: vuln.advisory.updatedAt,
                            withdrawnAt: vuln.advisory.withdrawnAt,
                            cvssScore: vuln.advisory.cvss?.score,
                            cvssVector: vuln.advisory.cvss?.vectorString,
                            references: vuln.advisory.references
                        }
                    });
                }
            }

            return vulnerabilities;
        } catch (error) {
            console.warn(`‚ö†Ô∏è Error consultando GitHub Advisory para ${packageName}:`, error.message);
            return [];
        }
    }

    /**
     * Extrae CVE de identificadores de GitHub
     */
    extractCVEFromGitHub(identifiers) {
        if (identifiers) {
            for (const id of identifiers) {
                if (id.type === 'CVE') {
                    return id.value;
                }
            }
        }
        return null;
    }

    /**
     * Normaliza la severidad
     */
    normalizeSeverity(severity) {
        if (!severity) return 'unknown';
        
        const normalized = severity.toLowerCase();
        const validSeverities = ['critical', 'high', 'moderate', 'low', 'info'];
        
        return validSeverities.includes(normalized) ? normalized : 'unknown';
    }

    /**
     * Obtiene todos los paquetes del proyecto
     */
    getAllPackages(includeDev = true) {
        const packages = [];
        
        if (this.packageJson.dependencies) {
            for (const [name, version] of Object.entries(this.packageJson.dependencies)) {
                packages.push({ name, version, isDev: false });
            }
        }
        
        if (includeDev && this.packageJson.devDependencies) {
            for (const [name, version] of Object.entries(this.packageJson.devDependencies)) {
                packages.push({ name, version, isDev: true });
            }
        }
        
        return packages;
    }

    /**
     * Consolida vulnerabilidades eliminando duplicados
     */
    consolidateVulnerabilities(allVulnerabilities) {
        const consolidated = new Map();
        
        for (const vuln of allVulnerabilities) {
            const key = `${vuln.packageName}-${vuln.id || vuln.title}`;
            
            if (!consolidated.has(key)) {
                consolidated.set(key, {
                    ...vuln,
                    sources: [vuln.source],
                    duplicateCount: 0
                });
            } else {
                const existing = consolidated.get(key);
                existing.sources.push(vuln.source);
                existing.duplicateCount++;
                
                // Mantener la severidad m√°s alta
                if (this.compareSeverity(vuln.severity, existing.severity) > 0) {
                    existing.severity = vuln.severity;
                }
            }
        }
        
        return Array.from(consolidated.values());
    }

    /**
     * Compara severidades
     */
    compareSeverity(severity1, severity2) {
        const severityOrder = {
            'critical': 4,
            'high': 3,
            'moderate': 2,
            'low': 1,
            'info': 0,
            'unknown': -1
        };
        
        return (severityOrder[severity1] || -1) - (severityOrder[severity2] || -1);
    }

    /**
     * Filtra vulnerabilidades por severidad
     */
    filterBySeverity(vulnerabilities, threshold) {
        const severityOrder = {
            'low': 1,
            'moderate': 2,
            'high': 3,
            'critical': 4,
            'info': 0
        };
        
        const thresholdValue = severityOrder[threshold] || 1;
        
        return vulnerabilities.filter(vuln => {
            const severityValue = severityOrder[vuln.severity] || 0;
            return severityValue >= thresholdValue;
        });
    }

    /**
     * Calcula el resumen del escaneo
     */
    calculateSummary(scanResult) {
        scanResult.summary = {
            total: scanResult.vulnerabilities.length,
            critical: 0,
            high: 0,
            moderate: 0,
            low: 0,
            info: 0
        };
        
        for (const vuln of scanResult.vulnerabilities) {
            scanResult.summary[vuln.severity]++;
        }
    }

    /**
     * Genera recomendaciones basadas en las vulnerabilidades
     */
    generateRecommendations(scanResult) {
        const recommendations = [];
        
        // Recomendaciones generales
        if (scanResult.summary.critical > 0) {
            recommendations.push({
                priority: 'critical',
                title: 'Vulnerabilidades cr√≠ticas detectadas',
                description: `Se encontraron ${scanResult.summary.critical} vulnerabilidades cr√≠ticas que requieren atenci√≥n inmediata.`,
                action: 'Actualice estos paquetes inmediatamente o considere alternativas m√°s seguras.'
            });
        }
        
        if (scanResult.summary.high > 0) {
            recommendations.push({
                priority: 'high',
                title: 'Vulnerabilidades de alta severidad',
                description: `Se encontraron ${scanResult.summary.high} vulnerabilidades de alta severidad.`,
                action: 'Planifique actualizaciones para estos paquetes en las pr√≥ximas 24-48 horas.'
            });
        }
        
        // Recomendaciones espec√≠ficas por paquete
        const packageVulns = new Map();
        for (const vuln of scanResult.vulnerabilities) {
            if (!packageVulns.has(vuln.packageName)) {
                packageVulns.set(vuln.packageName, []);
            }
            packageVulns.get(vuln.packageName).push(vuln);
        }
        
        for (const [packageName, vulns] of packageVulns) {
            const hasFix = vulns.some(v => v.fixAvailable);
            const maxSeverity = vulns.reduce((max, v) => 
                this.compareSeverity(v.severity, max) > 0 ? v.severity : max, 'low'
            );
            
            if (hasFix) {
                recommendations.push({
                    priority: maxSeverity,
                    title: `Actualizar ${packageName}`,
                    description: `El paquete ${packageName} tiene ${vulns.length} vulnerabilidades con correcciones disponibles.`,
                    action: `Ejecute: npm update ${packageName} o especifique una versi√≥n segura.`
                });
            } else {
                recommendations.push({
                    priority: maxSeverity,
                    title: `Evaluar alternativa para ${packageName}`,
                    description: `El paquete ${packageName} tiene vulnerabilidades sin correcci√≥n disponible.`,
                    action: 'Considere migrar a una alternativa m√°s segura o monitorear actualizaciones.'
                });
            }
        }
        
        // Recomendaciones de configuraci√≥n
        recommendations.push({
            priority: 'moderate',
            title: 'Establecer escaneos regulares',
            description: 'Configure escaneos autom√°ticos de vulnerabilidades.',
            action: 'Implemente CI/CD con verificaciones de seguridad peri√≥dicas.'
        });
        
        return recommendations.sort((a, b) => 
            this.compareSeverity(b.priority, a.priority)
        );
    }

    /**
     * Cuenta los paquetes escaneados
     */
    countPackagesScanned() {
        let count = 0;
        if (this.packageJson.dependencies) {
            count += Object.keys(this.packageJson.dependencies).length;
        }
        if (this.options.includeDevDependencies && this.packageJson.devDependencies) {
            count += Object.keys(this.packageJson.devDependencies).length;
        }
        return count;
    }

    /**
     * Cachear resultados del escaneo
     */
    cacheScanResults(scanResult) {
        const cacheKey = `scan_${scanResult.options.severity}_${scanResult.options.includeDev}`;
        this.cache.set(cacheKey, {
            result: scanResult,
            timestamp: Date.now()
        });
    }

    /**
     * Obtiene resultados cacheados
     */
    getCachedResults(options) {
        if (!this.options.cacheResults) {
            return null;
        }
        
        const cacheKey = `scan_${options.severity || this.options.severityThreshold}_${options.includeDev !== undefined ? options.includeDev : this.options.includeDevDependencies}`;
        const cached = this.cache.get(cacheKey);
        
        if (cached && (Date.now() - cached.timestamp) < this.options.cacheTimeout) {
            return cached.result;
        }
        
        return null;
    }

    /**
     * Genera un reporte detallado de vulnerabilidades
     */
    generateDetailedReport(scanResult) {
        const report = {
            ...scanResult,
            analysis: {
                riskScore: this.calculateRiskScore(scanResult),
                trendAnalysis: this.analyzeTrends(),
                packageRiskMatrix: this.generatePackageRiskMatrix(scanResult),
                securityMetrics: this.calculateSecurityMetrics(scanResult)
            },
            remediationPlan: this.generateRemediationPlan(scanResult),
            compliance: this.checkCompliance(scanResult)
        };
        
        return report;
    }

    /**
     * Calcula puntaje de riesgo
     */
    calculateRiskScore(scanResult) {
        const weights = {
            'critical': 10,
            'high': 7,
            'moderate': 4,
            'low': 2,
            'info': 1
        };
        
        let totalScore = 0;
        for (const vuln of scanResult.vulnerabilities) {
            totalScore += weights[vuln.severity] || 0;
        }
        
        // Normalizar a escala 0-100
        const maxPossibleScore = scanResult.metadata.packagesScanned * 10;
        return Math.min(100, Math.round((totalScore / maxPossibleScore) * 100));
    }

    /**
     * Analiza tendencias de vulnerabilidades
     */
    analyzeTrends() {
        if (this.scanHistory.length < 2) {
            return {
                trend: 'insufficient_data',
                message: 'Se necesitan m√°s escaneos para analizar tendencias'
            };
        }
        
        const recent = this.scanHistory[this.scanHistory.length - 1];
        const previous = this.scanHistory[this.scanHistory.length - 2];
        
        const trend = recent.summary.total > previous.summary.total ? 'increasing' : 
                     recent.summary.total < previous.summary.total ? 'decreasing' : 'stable';
        
        return {
            trend,
            change: recent.summary.total - previous.summary.total,
            period: `${new Date(previous.timestamp)} to ${new Date(recent.timestamp)}`
        };
    }

    /**
     * Genera matriz de riesgo por paquete
     */
    generatePackageRiskMatrix(scanResult) {
        const packageRisks = new Map();
        
        for (const vuln of scanResult.vulnerabilities) {
            if (!packageRisks.has(vuln.packageName)) {
                packageRisks.set(vuln.packageName, {
                    vulnerabilities: [],
                    maxSeverity: 'low',
                    fixAvailable: false,
                    riskScore: 0
                });
            }
            
            const packageRisk = packageRisks.get(vuln.packageName);
            packageRisk.vulnerabilities.push(vuln);
            
            if (this.compareSeverity(vuln.severity, packageRisk.maxSeverity) > 0) {
                packageRisk.maxSeverity = vuln.severity;
            }
            
            if (vuln.fixAvailable) {
                packageRisk.fixAvailable = true;
            }
        }
        
        // Calcular puntajes de riesgo
        for (const [packageName, risk] of packageRisks) {
            risk.riskScore = this.calculatePackageRiskScore(risk);
        }
        
        return Object.fromEntries(packageRisks);
    }

    /**
     * Calcula puntaje de riesgo para un paquete
     */
    calculatePackageRiskScore(packageRisk) {
        const severityWeights = {
            'critical': 10,
            'high': 7,
            'moderate': 4,
            'low': 2,
            'info': 1
        };
        
        let score = 0;
        for (const vuln of packageRisk.vulnerabilities) {
            score += severityWeights[vuln.severity] || 0;
        }
        
        // Reducir puntaje si hay fix disponible
        if (packageRisk.fixAvailable) {
            score = Math.round(score * 0.7);
        }
        
        return score;
    }

    /**
     * Calcula m√©tricas de seguridad
     */
    calculateSecurityMetrics(scanResult) {
        const totalPackages = scanResult.metadata.packagesScanned;
        const vulnerablePackages = new Set(
            scanResult.vulnerabilities.map(v => v.packageName)
        ).size;
        
        return {
            vulnerabilityDensity: totalPackages > 0 ? (vulnerablePackages / totalPackages * 100).toFixed(2) : 0,
            averageVulnerabilitiesPerPackage: totalPackages > 0 ? (scanResult.summary.total / totalPackages).toFixed(2) : 0,
            fixAvailabilityRate: scanResult.vulnerabilities.length > 0 ? 
                (scanResult.vulnerabilities.filter(v => v.fixAvailable).length / scanResult.vulnerabilities.length * 100).toFixed(2) : 100,
            criticalVulnerabilityPercentage: scanResult.summary.total > 0 ? 
                (scanResult.summary.critical / scanResult.summary.total * 100).toFixed(2) : 0
        };
    }

    /**
     * Genera plan de remediaci√≥n
     */
    generateRemediationPlan(scanResult) {
        const plan = {
            immediate: [],
            shortTerm: [],
            longTerm: [],
            monitoring: []
        };
        
        // Clasificar vulnerabilidades por urgencia
        for (const vuln of scanResult.vulnerabilities) {
            const action = {
                packageName: vuln.packageName,
                vulnerabilityId: vuln.id,
                severity: vuln.severity,
                description: vuln.title,
                recommendation: vuln.recommendation,
                estimatedEffort: this.estimateRemediationEffort(vuln)
            };
            
            if (vuln.severity === 'critical') {
                plan.immediate.push(action);
            } else if (vuln.severity === 'high') {
                plan.shortTerm.push(action);
            } else if (vuln.fixAvailable) {
                plan.shortTerm.push(action);
            } else {
                plan.longTerm.push(action);
            }
        }
        
        // Acciones de monitoreo
        plan.monitoring = [
            {
                action: 'Configurar escaneos autom√°ticos semanales',
                frequency: 'weekly',
                tool: 'npm audit + OSV database'
            },
            {
                action: 'Establecer alertas de seguridad',
                frequency: 'real-time',
                tool: 'GitHub Security Alerts'
            },
            {
                action: 'Revisar dependencias trimestralmente',
                frequency: 'quarterly',
                tool: 'Dependency review'
            }
        ];
        
        return plan;
    }

    /**
     * Estima el esfuerzo de remediaci√≥n
     */
    estimateRemediationEffort(vuln) {
        if (vuln.fixAvailable) {
            return 'low'; // Solo actualizar versi√≥n
        } else if (vuln.severity === 'critical' || vuln.severity === 'high') {
            return 'high'; // Puede requerir cambios significativos
        } else {
            return 'medium'; // Requiere investigaci√≥n y posiblemente cambios
        }
    }

    /**
     * Verifica cumplimiento de est√°ndares
     */
    checkCompliance(scanResult) {
        const compliance = {
            standards: [],
            overallScore: 0,
            gaps: []
        };
        
        // OWASP Top 10
        const owaspCompliance = {
            name: 'OWASP Top 10',
            score: this.calculateOWASPCompliance(scanResult),
            requirements: [
                'No vulnerabilidades cr√≠ticas conocidas',
                'Actualizaciones de seguridad aplicadas',
                'Dependencias verificadas regularmente'
            ]
        };
        compliance.standards.push(owaspCompliance);
        
        // ISO 27001
        const isoCompliance = {
            name: 'ISO 27001',
            score: this.calculateISOCompliance(scanResult),
            requirements: [
                'Gesti√≥n de vulnerabilidades',
                'Control de cambios',
                'Monitoreo de seguridad'
            ]
        };
        compliance.standards.push(isoCompliance);
        
        // Calcular puntaje general
        const totalScore = compliance.standards.reduce((sum, std) => sum + std.score, 0);
        compliance.overallScore = Math.round(totalScore / compliance.standards.length);
        
        // Identificar gaps
        if (scanResult.summary.critical > 0) {
            compliance.gaps.push('Vulnerabilidades cr√≠ticas sin resolver');
        }
        if (scanResult.summary.high > 5) {
            compliance.gaps.push('Alto n√∫mero de vulnerabilidades de alta severidad');
        }
        
        return compliance;
    }

    /**
     * Calcula cumplimiento OWASP
     */
    calculateOWASPCompliance(scanResult) {
        let score = 100;
        
        if (scanResult.summary.critical > 0) score -= 40;
        if (scanResult.summary.high > 0) score -= 25;
        if (scanResult.summary.moderate > 10) score -= 20;
        if (scanResult.summary.low > 20) score -= 10;
        
        return Math.max(0, score);
    }

    /**
     * Calcula cumplimiento ISO
     */
    calculateISOCompliance(scanResult) {
        let score = 100;
        
        if (scanResult.summary.critical > 0) score -= 30;
        if (scanResult.summary.high > 2) score -= 20;
        if (scanResult.vulnerabilities.length > scanResult.metadata.packagesScanned * 0.5) score -= 25;
        
        return Math.max(0, score);
    }

    /**
     * Exporta resultados a diferentes formatos
     */
    exportResults(scanResult, format = 'json') {
        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(scanResult, null, 2);
            case 'csv':
                return this.exportToCSV(scanResult);
            case 'html':
                return this.exportToHTML(scanResult);
            case 'pdf':
                return this.exportToPDF(scanResult);
            default:
                throw new Error(`Formato no soportado: ${format}`);
        }
    }

    /**
     * Exporta a formato CSV
     */
    exportToCSV(scanResult) {
        const headers = [
            'ID', 'Package', 'Severity', 'Title', 'Description', 
            'Fix Available', 'Source', 'CVE', 'Discovered At'
        ];
        
        const rows = scanResult.vulnerabilities.map(vuln => [
            vuln.id || '',
            vuln.packageName,
            vuln.severity,
            vuln.title,
            vuln.description?.replace(/"/g, '""') || '',
            vuln.fixAvailable ? 'Yes' : 'No',
            vuln.source,
            vuln.cve || '',
            vuln.discoveredAt
        ]);
        
        return [headers, ...rows]
            .map(row => row.map(cell => `"${cell}"`).join(','))
            .join('\n');
    }

    /**
     * Exporta a formato HTML
     */
    exportToHTML(scanResult) {
        return `
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #e9ecef; padding: 15px; border-radius: 5px; text-align: center; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .critical { border-left: 5px solid #dc3545; }
        .high { border-left: 5px solid #fd7e14; }
        .moderate { border-left: 5px solid #ffc107; }
        .low { border-left: 5px solid #28a745; }
        .info { border-left: 5px solid #17a2b8; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Vulnerability Scan Report</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <p>Scan ID: ${scanResult.scanId}</p>
    </div>
    
    <div class="summary">
        <div class="metric">
            <h3>${scanResult.summary.total}</h3>
            <p>Total Vulnerabilities</p>
        </div>
        <div class="metric">
            <h3>${scanResult.summary.critical}</h3>
            <p>Critical</p>
        </div>
        <div class="metric">
            <h3>${scanResult.summary.high}</h3>
            <p>High</p>
        </div>
        <div class="metric">
            <h3>${scanResult.summary.moderate}</h3>
            <p>Moderate</p>
        </div>
        <div class="metric">
            <h3>${scanResult.summary.low}</h3>
            <p>Low</p>
        </div>
    </div>
    
    <h2>Vulnerabilities</h2>
    ${scanResult.vulnerabilities.map(vuln => `
        <div class="vulnerability ${vuln.severity}">
            <h3>${vuln.title}</h3>
            <p><strong>Package:</strong> ${vuln.packageName}</p>
            <p><strong>Severity:</strong> ${vuln.severity}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            ${vuln.cve ? `<p><strong>CVE:</strong> ${vuln.cve}</p>` : ''}
            <p><strong>Fix Available:</strong> ${vuln.fixAvailable ? 'Yes' : 'No'}</p>
            <p><strong>Source:</strong> ${vuln.source}</p>
            ${vuln.recommendation ? `<p><strong>Recommendation:</strong> ${vuln.recommendation}</p>` : ''}
        </div>
    `).join('')}
    
    <h2>Recommendations</h2>
    ${scanResult.recommendations.map(rec => `
        <div class="vulnerability">
            <h3>${rec.title}</h3>
            <p><strong>Priority:</strong> ${rec.priority}</p>
            <p><strong>Description:</strong> ${rec.description}</p>
            <p><strong>Action:</strong> ${rec.action}</p>
        </div>
    `).join('')}
</body>
</html>`;
    }

    /**
     * Exporta a formato PDF (placeholder)
     */
    exportToPDF(scanResult) {
        // En producci√≥n, usar√≠a una librer√≠a como puppeteer o jsPDF
        return 'PDF export not implemented yet. Use HTML export and convert to PDF.';
    }
}

module.exports = VulnerabilityScanner;